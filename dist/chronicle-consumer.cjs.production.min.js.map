{"version":3,"file":"chronicle-consumer.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import WebSocket from \"ws\";\nimport EventEmitter from \"events\";\nimport Emittery from \"emittery\";\n\ntype EmitterType = {\n  type: 'sync'\n  adapter: EventEmitter\n} | {\n  type: 'async'\n  adapter: Emittery\n}\nclass ConsumerServer<T extends WebSocket = WebSocket> {\n  private wsPort: number;\n  private wsHost: string\n  private ackEvery: number;\n  private interactive: boolean;\n  private async: boolean;\n  private emitter: EmitterType; // Emittery or EventEmitter   \n  private typemap = new Map<number, string>(); // @TODO: narrow down the values \n  private confirmed_block: number;\n  private unconfirmed_block: number;\n  private server?: WebSocket.Server<T>;\n  private chronicleConnection?: T\n  private asyncTasksInProcessingCounter = 0;\n  private asyncMaxTasksThreshold: number | undefined;\n\n\n  constructor(opts: {\n    port: number,\n    host?: string,\n    ackEvery?: number\n    interactive?: boolean\n    async?: boolean\n    asyncMaxTasksThreshold?: number\n  }) {\n    if (!opts.port) {\n      throw Error(\"port not defined\");\n    }\n\n    this.wsPort = opts.port;\n\n    this.wsHost = '0.0.0.0';\n    if (opts.host) {\n      this.wsHost = opts.host;\n    }\n\n    this.ackEvery = 100;\n    if (opts.ackEvery) {\n      this.ackEvery = opts.ackEvery;\n    }\n\n    this.interactive = false;\n    if (opts.interactive) {\n      this.interactive = true;\n    }\n\n    if (opts.async) {\n      this.async = true;\n      this.emitter = {\n        type: 'async',\n        adapter: new Emittery()\n      }\n      if (opts.asyncMaxTasksThreshold) {\n        this.asyncMaxTasksThreshold = opts.asyncMaxTasksThreshold;\n      } else {\n        throw new Error(\"must define `asyncMaxTasksThreshold` in async mode\")\n      }\n    } else {\n      this.async = false;\n      this.emitter = {\n        type: 'sync',\n        adapter: new EventEmitter()\n      }\n    }\n\n\n\n    this.typemap = new Map();\n    this.typemap.set(1001, 'fork');\n    this.typemap.set(1002, 'block');\n    this.typemap.set(1003, 'tx');\n    this.typemap.set(1004, 'abi');\n    this.typemap.set(1005, 'abiRemoved');\n    this.typemap.set(1006, 'abiError');\n    this.typemap.set(1007, 'tableRow');\n    this.typemap.set(1008, 'encoderError');\n    this.typemap.set(1009, 'pause');\n    this.typemap.set(1010, 'blockCompleted');\n    this.typemap.set(1011, 'permission');\n    this.typemap.set(1012, 'permissionLink');\n    this.typemap.set(1013, 'accMetadata');\n\n    this.confirmed_block = 0;\n    this.unconfirmed_block = 0;\n  }\n\n  start() {\n    console.log('Starting Chronicle consumer on ' + this.wsHost + ':' + this.wsPort);\n    console.log('Acknowledging every ' + this.ackEvery + ' blocks');\n\n    this.server = new WebSocket.Server({ host: this.wsHost, port: this.wsPort });\n    this.server.on('connection', this._onConnection.bind(this));\n  }\n\n  stop() {\n    this.server?.close();\n  }\n\n  on(eventName, listener) { return this.emitter.adapter.on(eventName, listener) }\n  off(eventName, listener) { return this.emitter.adapter.off(eventName, listener) }\n  once(eventName, listener) { return this.emitter.adapter.once(eventName, listener) }\n\n\n  async requestBlocks(start, end) {\n    if (!this.interactive) {\n      throw Error('requestBlocks can only be called in interactive mode');\n    }\n\n    if (start > end) {\n      throw Error('start block should not be lower than end');\n    }\n\n    this.chronicleConnection?.send(start.toString(10) + '-' + end.toString(10));\n  }\n\n  closeHandler(socket, emitDisconnect = true) {\n    try {\n      socket.close();\n    } catch (err) {\n      console.error('Graceful close of websocket threw error', err);\n    } finally {\n      if (emitDisconnect) {\n        this['kConsumerServerClientConnected'] = false;\n        this.emitter.adapter.emit('disconnected', {\n          remoteAddress: socket._socket.remoteAddress,\n          remoteFamily: socket._socket.remoteFamily,\n          remotePort: socket._socket.remotePort\n        });\n      }\n    }\n  }\n\n  _onConnection(socket) {\n    if (this['kConsumerServerClientConnected']) {\n      console.error('Rejected a new Chronicle connection because one is active already');\n      return this.closeHandler(socket, false);\n    }\n\n    this['kConsumerServerClientConnected'] = true;\n    this.chronicleConnection = socket;\n    this.emitter.adapter.emit('connected', {\n      remoteAddress: socket._socket.remoteAddress,\n      remoteFamily: socket._socket.remoteFamily,\n      remotePort: socket._socket.remotePort\n    });\n\n    socket.on('close', () => {\n      console.log('Graceful close of Chronicle connection initiated');\n      this.closeHandler(socket);\n    });\n\n    socket.on('error', () => {\n      console.error('Error close of Chronicle connection initiated');\n      this.closeHandler(socket);\n    });\n\n    socket.on('message', (data) => {\n      const msgType = data.readInt32LE(0);\n      const opts = data.readInt32LE(4);\n      const msg = JSON.parse(data.toString('utf8', 8));\n\n      const event = this.typemap.get(msgType);\n      if (!event) {\n        throw Error('Unknown msgType: ' + msgType);\n      }\n\n      const res = this.emitter.adapter.emit(event, msg);\n      if (this.async) {\n        if (typeof res === 'boolean') throw new Error(\"in async mode res should be a promise, not boolean\")\n\n        // once promise comes in -- increment the counter\n        this.asyncTasksInProcessingCounter++;\n        // console.log(\"tasksTracker: consumerModule: counter incr: event+traceId:\", `${event}+${msg?.trace?.id}`)\n        res.finally(() => {\n          // console.log(\"tasksTracker: consumerModule: counter decr: event+traceId:\", `${event}+${msg?.trace?.id}`)\n          // once promise is resolved -- decrement the counter\n          if (this.asyncTasksInProcessingCounter === this.asyncMaxTasksThreshold) {\n            // if going below threshold, enforce ack\n            // console.log(\"enforcing ack signal because threshold surpassed\")\n            this._async_ack(this.confirmed_block);\n          }\n          this.asyncTasksInProcessingCounter--;\n        });\n      }\n\n      let block_num;\n      let do_ack = false;\n      switch (msgType) {\n\n        case 1010:           /* BLOCK_COMPLETED */\n          block_num = msg['block_num'];\n          this.unconfirmed_block = block_num;\n          if (this.unconfirmed_block - this.confirmed_block >= this.ackEvery) {\n            this.confirmed_block = block_num;\n            do_ack = true;\n          }\n          break;\n\n        case 1001:           /* FORK */\n          block_num = msg['block_num'];\n          this.confirmed_block = block_num - 1;\n          this.unconfirmed_block = block_num - 1;\n          do_ack = true;\n          break;\n      }\n\n      if (do_ack) {\n        if (this.async) {\n\n          if (!this.asyncMaxTasksThreshold) throw new Error(\"asyncMaxTasksThreshold must be defined in async mode\")\n\n          if (this.asyncTasksInProcessingCounter >= this.asyncMaxTasksThreshold) {\n            // console.log(\"received ack signal but not sending ack, because threshold not passed: this.asyncTasksInProcessingCounter >= this.asyncMaxTasksThreshold\", `${this.asyncTasksInProcessingCounter} >= ${this.asyncMaxTasksThreshold}`)\n            return;\n          } else {\n            // console.log(\"received ack signal and sending ack, because threshold passed: this.asyncTasksInProcessingCounter >= this.asyncMaxTasksThreshold\", `${this.asyncTasksInProcessingCounter} >= ${this.asyncMaxTasksThreshold}`)\n          }\n          // if we're here, then we're ready to send ack\n          this._async_ack(this.confirmed_block);\n        }\n        else {\n          this._sync_ack(this.confirmed_block);\n        }\n      }\n    });\n  }\n\n  async _async_ack(ack_block_number) {\n    if (!this.chronicleConnection) throw new Error('chronicleConnection must be defined')\n\n    if (!this.interactive) {\n      if (this.emitter.type !== 'async') throw new Error('emitter type must be async')\n\n      try {\n        await this.emitter.adapter.emit('ackBlock', ack_block_number);\n        this.chronicleConnection.send(ack_block_number.toString(10));\n      } catch (e) {\n        console.error('critical error: ackBlock listener threw error')\n      }\n\n    }\n  }\n\n  _sync_ack(ack_block_number) {\n    if (!this.chronicleConnection) throw new Error('chronicleConnection must be defined')\n\n    if (!this.interactive) {\n      this.emitter.adapter.emit('ackBlock', ack_block_number);\n      this.chronicleConnection.send(ack_block_number.toString(10));\n    }\n  }\n}\n\n\n\nmodule.exports = ConsumerServer;\n"],"names":["module","exports","ConsumerServer","opts","this","wsPort","wsHost","ackEvery","interactive","async","emitter","typemap","Map","confirmed_block","unconfirmed_block","server","chronicleConnection","asyncTasksInProcessingCounter","asyncMaxTasksThreshold","port","Error","host","type","adapter","Emittery","EventEmitter","set","start","console","log","WebSocket","Server","on","_onConnection","bind","stop","_this$server","close","eventName","listener","off","once","requestBlocks","end","_this$chronicleConnec","_regeneratorRuntime","wrap","_context","prev","next","send","toString","_callee","closeHandler","socket","emitDisconnect","err","error","emit","remoteAddress","_socket","remoteFamily","remotePort","_this","data","msgType","readInt32LE","msg","JSON","parse","event","get","block_num","res","_async_ack","do_ack","_sync_ack","_async_ack2","_asyncToGenerator","mark","_callee2","ack_block_number","_context2","t0"],"mappings":"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"}